---
import '../styles/global.css';
import Navigation from '../components/Navigation.astro';
---

<html lang="fr">
	<head>
		<meta charset="utf-8" />
		<link rel="icon" type="image/svg+xml" href="/favicon.svg" />
		<meta name="viewport" content="width=device-width" />
		<meta name="generator" content={Astro.generator} />
		<title>Niveau 5 - ScrollTrigger Camera | Three.js</title>
	</head>
	<body class="bg-gray-900">
		<Navigation />
		
		<!-- Sections pour le scroll -->
		<div class="relative">
			<section class="h-screen flex items-center justify-center">
				<canvas id="canvas3d" class="fixed top-0 left-0 w-full h-screen"></canvas>
			</section>
			<section class="h-screen flex items-center justify-center relative z-10">
				<div class="bg-black/50 backdrop-blur-md p-8 rounded-2xl max-w-md">
					<h3 class="text-2xl font-bold text-white mb-4">Vue de Face</h3>
					<p class="text-gray-300">La caméra se déplace en fonction de votre scroll pour révéler différents angles de la scène.</p>
				</div>
			</section>
			<section class="h-screen flex items-center justify-center relative z-10">
				<div class="bg-black/50 backdrop-blur-md p-8 rounded-2xl max-w-md">
					<h3 class="text-2xl font-bold text-white mb-4">Vue Latérale</h3>
					<p class="text-gray-300">Découvrez les formes géométriques sous tous les angles avec une animation fluide.</p>
				</div>
			</section>
			<section class="h-screen flex items-center justify-center relative z-10">
				<div class="bg-black/50 backdrop-blur-md p-8 rounded-2xl max-w-md">
					<h3 class="text-2xl font-bold text-white mb-4">Vue Finale</h3>
					<p class="text-gray-300">L'orchestration complète de la scène 3D révélée par le scroll.</p>
				</div>
			</section>
		</div>
	</body>
</html>

<script>
	import * as THREE from 'three';
	import { gsap } from 'gsap';
	import { ScrollTrigger } from 'gsap/ScrollTrigger';

	gsap.registerPlugin(ScrollTrigger);

	// Configuration de la scène
	const canvas = document.getElementById('canvas3d') as HTMLCanvasElement;
	const scene = new THREE.Scene();
	scene.background = new THREE.Color(0x0a0a1a);
	scene.fog = new THREE.Fog(0x0a0a1a, 10, 50);

	// Configuration de la caméra
	const camera = new THREE.PerspectiveCamera(
		75,
		window.innerWidth / window.innerHeight,
		0.1,
		1000
	);
	camera.position.set(0, 0, 10);

	// Configuration du renderer
	const renderer = new THREE.WebGLRenderer({ 
		canvas,
		antialias: true,
		alpha: true
	});
	renderer.setSize(window.innerWidth, window.innerHeight);
	renderer.setPixelRatio(window.devicePixelRatio);
	renderer.shadowMap.enabled = true;

	// Création d'un groupe central pour les objets
	const mainGroup = new THREE.Group();
	scene.add(mainGroup);

	// Sphère principale
	const sphereGeometry = new THREE.SphereGeometry(2, 64, 64);
	const sphereMaterial = new THREE.MeshStandardMaterial({
		color: 0xFFFFFF,
		metalness: 0,
		roughness: 0.5,
		envMapIntensity: 1
	});
	const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
	sphere.castShadow = true;
	mainGroup.add(sphere);

	// Torus autour
	const torusGeometry = new THREE.TorusGeometry(3.5, 0.4, 32, 100);
	const torusMaterial = new THREE.MeshStandardMaterial({
		color: 0xFFFFFF,
		metalness: 0,
		roughness: 0.5
	});
	const torus = new THREE.Mesh(torusGeometry, torusMaterial);
	torus.rotation.x = Math.PI / 4;
	torus.castShadow = true;
	mainGroup.add(torus);

	// Cubes satellites
	const cubes: THREE.Mesh[] = [];
	for (let i = 0; i < 6; i++) {
		const cubeGeometry = new THREE.BoxGeometry(0.8, 0.8, 0.8);
		const cubeMaterial = new THREE.MeshStandardMaterial({
			color: 0xFFFFFF,
			metalness: 0,
			roughness: 0.5
		});
		const cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
		
		const angle = (i / 8) * Math.PI * 2;
		cube.position.set(
			Math.cos(angle) * 5,
			Math.sin(angle * 2) * 2,
			Math.sin(angle) * 5
		);
		cube.castShadow = true;
		mainGroup.add(cube);
		cubes.push(cube);
	}

	// Lumières
	const ambientLight = new THREE.AmbientLight(0x404080, 0.6);
	scene.add(ambientLight);

	const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
	directionalLight.position.set(10, 10, 10);
	directionalLight.castShadow = true;
	scene.add(directionalLight);

	const pointLight1 = new THREE.PointLight(0xff6b9d, 2, 30);
	pointLight1.position.set(-5, 5, 5);
	scene.add(pointLight1);

	const pointLight2 = new THREE.PointLight(0x4ecdc4, 2, 30);
	pointLight2.position.set(5, -5, 5);
	scene.add(pointLight2);


	// ScrollTrigger pour animer la caméra
	const timeline = gsap.timeline({
		scrollTrigger: {
			trigger: 'body',
			start: 'top top',
			end: 'bottom bottom',
			scrub: 1,
			markers: true
		}
	});

	// Animation de la caméra en fonction du scroll
	timeline
		.to(camera.position, {
			x: 8,
			y: 3,
			z: 8,
			duration: 1
		})
		.to(camera.position, {
			x: -8,
			y: 5,
			z: 5,
			duration: 1
		})
		.to(camera.position, {
			x: 0,
			y: 10,
			z: 15,
			duration: 1
		});

	// Animation du groupe principal
	timeline
		.to(mainGroup.rotation, {
			y: Math.PI * 2,
			duration: 3
		}, 0)
		.to(mainGroup.position, {
			y: 2,
			duration: 1.5,
			yoyo: true,
			repeat: 1
		}, 0);

	// Gestion du redimensionnement
	window.addEventListener('resize', () => {
		camera.aspect = window.innerWidth / window.innerHeight;
		camera.updateProjectionMatrix();
		renderer.setSize(window.innerWidth, window.innerHeight);
	});

	// Boucle d'animation
	function animate() {
		requestAnimationFrame(animate);

		// La caméra regarde toujours le centre
		camera.lookAt(0, 0, 0);

		renderer.render(scene, camera);
	}

	animate();
</script>
