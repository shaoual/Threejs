---
import '../styles/global.css';
import Navigation from '../components/Navigation.astro';
---

<html lang="fr">
	<head>
		<meta charset="utf-8" />
		<link rel="icon" type="image/svg+xml" href="/favicon.svg" />
		<meta name="viewport" content="width=device-width" />
		<meta name="generator" content={Astro.generator} />
		<title>Niveau 6 - Modèle 3D | Three.js</title>
	</head>
	<body class="bg-gray-900 overflow-hidden">
		<Navigation />
		<canvas id="canvas3d" class="w-full h-screen"></canvas>
	</body>
</html>

<script>
	import * as THREE from 'three';
	import { gsap } from 'gsap';
	import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';

	// Configuration de la scène
	const canvas = document.getElementById('canvas3d') as HTMLCanvasElement;
	const scene = new THREE.Scene();
	scene.background = new THREE.Color(0xf5f5f0);
	scene.fog = new THREE.Fog(0xf5f5f0, 10, 50);

	// Configuration de la caméra
	const camera = new THREE.PerspectiveCamera(
		35,
		window.innerWidth / window.innerHeight,
		0.1,
		1000
	);
	camera.position.set(5, 3, 5);

	// Configuration du renderer
	const renderer = new THREE.WebGLRenderer({ 
		canvas,
		antialias: true 
	});
	renderer.setSize(window.innerWidth, window.innerHeight);
	renderer.setPixelRatio(window.devicePixelRatio);
	renderer.shadowMap.enabled = true;
	renderer.shadowMap.type = THREE.PCFSoftShadowMap;
	renderer.toneMapping = THREE.ACESFilmicToneMapping;
	renderer.toneMappingExposure = 1.2;

	// Sol
	// const floorGeometry = new THREE.CircleGeometry(10, 64);
	// const floorMaterial = new THREE.MeshStandardMaterial({
	// 	color: 0xe8e8e8,
	// 	metalness: 0.1,
	// 	roughness: 0.8
	// });
	// const floor = new THREE.Mesh(floorGeometry, floorMaterial);
	// floor.rotation.x = -Math.PI / 2;
	// floor.position.y = -1;
	// floor.receiveShadow = true;
	// scene.add(floor);

	// Lumières
	const ambientLight = new THREE.AmbientLight(0xffffff, 2);
	scene.add(ambientLight);

	const directionalLight = new THREE.DirectionalLight(0xffffff, 2);
	directionalLight.position.set(5, 10, 5);
	// directionalLight.castShadow = true;
	// directionalLight.shadow.camera.left = -10;
	// directionalLight.shadow.camera.right = 10;
	// directionalLight.shadow.camera.top = 10;
	// directionalLight.shadow.camera.bottom = -10;
	// directionalLight.shadow.mapSize.width = 2048;
	// directionalLight.shadow.mapSize.height = 2048;
	scene.add(directionalLight);

	// Lumière de remplissage
	const fillLight = new THREE.DirectionalLight(0xffffff, 0.5);
	fillLight.position.set(-5, 5, -5);
	scene.add(fillLight);

	// Rim light pour effet premium
	const rimLight = new THREE.DirectionalLight(0xffffff, 1);
	rimLight.position.set(0, 3, -5);
	scene.add(rimLight);

	// Chargement du modèle 3D
	const loader = new GLTFLoader();
	let model: THREE.Group;
	let modelGroup = new THREE.Group();
	scene.add(modelGroup);

	loader.load(
		'/bouilloire-etape13-optim.glb',
		(gltf) => {
			model = gltf.scene;
			
			// Ajuster l'échelle et la position
			model.scale.set(2, 2, 2);
			model.position.y = -1;
			
			// Activer les ombres pour tous les meshes
			model.traverse((child) => {
				if (child instanceof THREE.Mesh) {
					child.castShadow = true;
					child.receiveShadow = true;
					
					// Améliorer les matériaux
					if (child.material) {
						child.material.envMapIntensity = 1.5;
					}
				}
			});

			modelGroup.add(model);

			// Animations GSAP sur le modèle
			gsap.to(modelGroup.rotation, {
				y: Math.PI * 2,
				duration: 20,
				repeat: -1,
				ease: 'none'
			});

			// Animation de lévitation
			gsap.to(modelGroup.position, {
				y: 0.3,
				duration: 2,
				yoyo: true,
				repeat: -1,
				ease: 'sine.inOut'
			});

			// Animation d'introduction
			gsap.from(model.scale, {
				x: 0,
				y: 0,
				z: 0,
				duration: 1.5,
				ease: 'elastic.out(1, 0.5)'
			});

			console.log('Modèle chargé avec succès');
		},
		(progress) => {
			console.log('Chargement:', (progress.loaded / progress.total * 100) + '%');
		},
		(error) => {
			console.error('Erreur de chargement:', error);
		}
	);

	// Particules flottantes pour ambiance
	const particlesGeometry = new THREE.BufferGeometry();
	const particlesCount = 100;
	const posArray = new Float32Array(particlesCount * 3);

	for (let i = 0; i < particlesCount * 3; i++) {
		posArray[i] = (Math.random() - 0.5) * 20;
	}

	particlesGeometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
	const particlesMaterial = new THREE.PointsMaterial({
		size: 0.05,
		color: 0xcccccc,
		transparent: true,
		opacity: 0.3
	});

	const particlesMesh = new THREE.Points(particlesGeometry, particlesMaterial);
	scene.add(particlesMesh);

	// Contrôle souris pour interaction
	let mouseX = 0;
	let mouseY = 0;
	let targetRotationX = 0;
	let targetRotationY = 0;

	document.addEventListener('mousemove', (event) => {
		mouseX = (event.clientX / window.innerWidth) * 2 - 1;
		mouseY = -(event.clientY / window.innerHeight) * 2 + 1;
		
		targetRotationY = mouseX * 0.3;
		targetRotationX = mouseY * 0.3;
	});

	// Gestion du redimensionnement
	window.addEventListener('resize', () => {
		camera.aspect = window.innerWidth / window.innerHeight;
		camera.updateProjectionMatrix();
		renderer.setSize(window.innerWidth, window.innerHeight);
	});

	// Boucle d'animation
	function animate() {
		requestAnimationFrame(animate);

		// Rotation douce basée sur la souris
		if (modelGroup) {
			modelGroup.rotation.x += (targetRotationX - modelGroup.rotation.x) * 0.05;
		}

		// Animation subtile des particules
		particlesMesh.rotation.y += 0.0003;

		// La caméra regarde le centre avec un léger offset basé sur la souris
		camera.position.x += (mouseX * 2 - camera.position.x + 5) * 0.02;
		camera.position.y += (mouseY * 2 - camera.position.y + 3) * 0.02;
		camera.lookAt(0, 0, 0);

		renderer.render(scene, camera);
	}

	animate();
</script>
