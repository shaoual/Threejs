---
import '../styles/global.css';
import Navigation from '../components/Navigation.astro';
import { Image } from 'astro:assets';
import rendu06 from '../img/rendu-06.jpg';
import rendu07 from '../img/rendu-07.jpg';
import rendu08 from '../img/rendu-08.jpg';
---

<html lang="fr">
	<head>
		<meta charset="utf-8" />
		<link rel="icon" type="image/svg+xml" href="/favicon.svg" />
		<meta name="viewport" content="width=device-width" />
		<meta name="generator" content={Astro.generator} />
		<title>Niveau 10 - ScrollTrigger 3D Model | Three.js</title>
	</head>
	<body class="bg-gray-900">
		<Navigation />

		
		<!-- Sections pour le scroll -->
		<div class="relative">
			<section class="h-screen flex items-center ml-10 justify-center">
				<canvas id="canvas3d" class="fixed top-0 left-0 w-full h-screen"></canvas>
			</section>
			<section class="h-screen flex items-center ml-10 relative z-10">
				<div class="bg-black/50 backdrop-blur-md p-8 rounded-2xl max-w-md">
					<h3 class="text-2xl font-bold text-white mb-4">Vue de Face</h3>
					<Image src={rendu06} alt="Rendu de face" class="w-full h-48 object-cover rounded-lg mb-4" />
					<p class="text-gray-300">La caméra se déplace autour du modèle 3D en fonction de votre scroll pour révéler tous ses détails.</p>
				</div>
			</section>
			<section class="h-screen flex items-center ml-10 relative z-10">
				<div class="bg-black/50 backdrop-blur-md p-8 rounded-2xl max-w-md">
					<h3 class="text-2xl font-bold text-white mb-4">Vue Latérale</h3>
					<Image src={rendu07} alt="Rendu latéral" class="w-full h-48 object-cover rounded-lg mb-4" />
					<p class="text-gray-300">Découvrez le modèle sous tous les angles avec une animation fluide pilotée par le scroll.</p>
				</div>
			</section>
			<section class="h-screen flex items-center ml-10 relative z-10">
				<div class="bg-black/50 backdrop-blur-md p-8 rounded-2xl max-w-md">
					<h3 class="text-2xl font-bold text-white mb-4">Vue Finale</h3>
					<Image src={rendu08} alt="Rendu final" class="w-full h-48 object-cover rounded-lg mb-4" />
					<p class="text-gray-300">L'orchestration complète révélée avec un éclairage dynamique et des effets atmosphériques.</p>
				</div>
			</section>
		</div>
	</body>
</html>

<script>
	// Importation des bibliothèques nécessaires
	import * as THREE from 'three';
	import { gsap } from 'gsap';
	import { ScrollTrigger } from 'gsap/ScrollTrigger';
	import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';
  // Importation du loader pour les textures HDR (High Dynamic Range)
	import { RGBELoader } from 'three/examples/jsm/loaders/RGBELoader.js';

	// Enregistrement du plugin ScrollTrigger
	gsap.registerPlugin(ScrollTrigger);

	// === CONFIGURATION DE BASE ===
	
	// Récupération du canvas HTML
	const canvas = document.getElementById('canvas3d') as HTMLCanvasElement;
	
	// Création de la scène
	const scene = new THREE.Scene();
	scene.background = new THREE.Color(0x0a0a1a);
	scene.fog = new THREE.Fog(0x0a0a1a, 10, 50);

	// Configuration de la caméra
	const camera = new THREE.PerspectiveCamera(
		35,
		window.innerWidth / window.innerHeight,
		0.1,
		1000
	);
	camera.position.set(0, 1, 5);

	// Configuration du renderer
	const renderer = new THREE.WebGLRenderer({ 
		canvas,
		antialias: true,
		alpha: true
	});
	renderer.setSize(window.innerWidth, window.innerHeight);
	renderer.setPixelRatio(window.devicePixelRatio);
	renderer.shadowMap.enabled = true;
	renderer.shadowMap.type = THREE.PCFSoftShadowMap;
	renderer.toneMapping = THREE.ACESFilmicToneMapping;
	renderer.toneMappingExposure = 1.2;

  // === CHARGEMENT DE LA TEXTURE D'ENVIRONNEMENT HDR ===
	
	// Création d'un loader pour les textures HDR (format RGBE)
	const rgbeLoader = new RGBELoader();
	// Chargement asynchrone de la texture HDR d'environnement
	rgbeLoader.load(
		// URL de la texture HDR (studio lighting)
		'https://dl.polyhaven.org/file/ph-assets/HDRIs/hdr/1k/studio_small_08_1k.hdr',
		(texture) => {
			// Configuration de la texture en mapping équirectangulaire
			texture.mapping = THREE.EquirectangularReflectionMapping;
			// Application de la texture comme environnement de la scène
			// Cela fournit l'éclairage IBL (Image Based Lighting) et les reflets
			scene.environment = texture;
			// Optionnel: utiliser aussi comme fond (commenté pour garder le fond bleu)
			// scene.background = texture;
		}
	);

	// === CHARGEMENT DU MODÈLE 3D ===
	
	// Groupe principal pour contenir le modèle
	const mainGroup = new THREE.Group();
	scene.add(mainGroup);

	// Loader pour fichiers GLTF/GLB
	const gltfLoader = new GLTFLoader();
	let loadedModel: THREE.Group;

	// Chargement du modèle depuis le dossier public
	gltfLoader.load(
		'/TP_Blender_Mug.glb',
		(gltf) => {
			loadedModel = gltf.scene;
			
			// Configuration du modèle - centré au milieu de la scène
			loadedModel.scale.set(0.7, 0.7, 0.7);
			loadedModel.position.set(0, -1, 0);
			
			// Activation des ombres pour tous les meshes
			loadedModel.traverse((child) => {
				if (child instanceof THREE.Mesh) {
					child.castShadow = true;
					child.receiveShadow = true;
					// Amélioration des matériaux si nécessaire
					if (child.material) {
						child.material.envMapIntensity = 1.5;
					}
				}
			});
			
			mainGroup.add(loadedModel);
		},
		// Callback de progression
		(progress) => {
			console.log('Chargement: ' + (progress.loaded / progress.total * 100) + '%');
		},
		// Callback d'erreur
		(error) => {
			console.error('Erreur de chargement du modèle:', error);
		}
	);

	// === SYSTÈME D'ÉCLAIRAGE ===
	
	// Lumière ambiante pour éclairer légèrement toute la scène
	const ambientLight = new THREE.AmbientLight(0x404080, 0.8);
	scene.add(ambientLight);

	// Lumière directionnelle principale (éclairage du haut)
	const directionalLight = new THREE.DirectionalLight(0xffffff, 5);
	directionalLight.position.set(10, 10, 10);
	directionalLight.castShadow = true;
	directionalLight.shadow.mapSize.width = 2048;
	directionalLight.shadow.mapSize.height = 2048;
	scene.add(directionalLight);

	// Lumière ponctuelle rose (accent gauche)
	const pointLight1 = new THREE.PointLight(0xff6b9d, 3, 30);
	pointLight1.position.set(-5, 3, 5);
	scene.add(pointLight1);

	// Lumière ponctuelle cyan (accent droit)
	const pointLight2 = new THREE.PointLight(0x4ecdc4, 3, 30);
	pointLight2.position.set(5, 3, 5);
	scene.add(pointLight2);

	// Lumière arrière pour le rim lighting
	const rimLight = new THREE.SpotLight(0xffffff, 2);
	rimLight.position.set(0, 5, -5);
	rimLight.angle = Math.PI / 6;
	scene.add(rimLight);

	// === SOL CIRCULAIRE ===
	
	// const groundGeometry = new THREE.CircleGeometry(8, 64);
	// const groundMaterial = new THREE.MeshStandardMaterial({
	// 	color: 0x1a1a2e,
	// 	metalness: 0,
	// 	roughness: 1
	// });
	// const ground = new THREE.Mesh(groundGeometry, groundMaterial);
	// ground.rotation.x = -Math.PI / 2;
	// ground.position.y = -1;
	// ground.receiveShadow = true;
	// scene.add(ground);

	// === SCROLLTRIGGER ANIMATIONS ===
	
	// Timeline principale pilotée par le scroll
	const timeline = gsap.timeline({
		scrollTrigger: {
      trigger: 'body', // Élément qui déclenche l'animation (ici tout le body)
			start: 'top top', // Début de l'animation : quand le haut du body atteint le haut du viewport
			end: 'bottom bottom', // Fin de l'animation : quand le bas du body atteint le bas du viewport
			scrub: 1, // Synchronisation avec le scroll (1 = lissage d'1 seconde pour des mouvements fluides)
			markers: true // Affichage des marqueurs de debug (false = désactivé)
		}
	});

	// Paramètres de la rotation circulaire
	const radius = 5; // Distance de la caméra par rapport à l'objet (réduite)
	const cameraHeight = 1; // Hauteur de la caméra (constante)

	// Animation de la caméra : rotation complète de 360° autour de l'objet
	// Utilisation de coordonnées polaires pour un cercle parfait
	timeline
		// 0° - Position de départ (devant)
		.to(camera.position, {
			x: 0,
			y: 1,
			z: 5,
			duration: 1
		})
		// 90° - Côté droit
		.to(camera.position, {
			x: 3,
			y: 0,
			z: 2,
			duration: 1
		})
    .to(camera.position, {
			x: 3,
			y: 0,
			z: 2,
			duration: 1
		})
		// 360° - Retour au départ
		.to(camera.position, {
			x: 0,
			y: 1,
			z: 5,
			duration: 1
		});

  timeline
		.to(mainGroup.rotation, {
			y: Math.PI * 2,
			duration: 3
		}, 0)
		// .to(mainGroup.position, {
		// 	y: 2,
		// 	duration: 1.5,
		// 	yoyo: true,
		// 	repeat: 1
		// }, 0);

	// === GESTION DU REDIMENSIONNEMENT ===
	
	window.addEventListener('resize', () => {
		camera.aspect = window.innerWidth / window.innerHeight;
		camera.updateProjectionMatrix();
		renderer.setSize(window.innerWidth, window.innerHeight);
	});

	// === BOUCLE D'ANIMATION ===
	
	function animate() {
		requestAnimationFrame(animate);

		// La caméra regarde toujours le centre de la scène
		camera.lookAt(0, 0, 0);

		// Rendu de la scène
		renderer.render(scene, camera);
	}

	// Démarrage de l'animation
	animate();
</script>
